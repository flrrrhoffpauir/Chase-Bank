import flash.filters.BlurFilter;/*	Call the itemSelected(indexNumberHere:Number) function to transition btw the items (fyi: the index starts at zero)	!!!!!   An "init" function call is located at the bottom of this file to start up the carousel   !!!!!*/// set the "width" and "height" of the carouselvar radiusX:Number = 120;var radiusY:Number = 15;// set the center x,y coord for the container clip that holds all the itemsvar centerX:Number = Stage.width / 2;var centerY:Number = Stage.height / 3;// set the speed of the transition to the next positionvar speed:Number = 0.5;// set perspectiveswitch(Stage.height){	case 60:		var perspective:Number = 2;		break;	case 90:		var perspective:Number = 10;		break;	default:		var perspective:Number = 60;		break;}// var perspective:Number = (Stage.height < 160) ? 10 : 60;var distToTravel:Number;// for the items not in "spotlight" positionvar alphaAmount:Number = 50; // blur for the transitionvar blur:BlurFilter = new BlurFilter(0,0,3);// create the container for the rotating itemsvar container:MovieClip = this.createEmptyMovieClip("container", 10);// positive: clockwise// negative: anti-clockwisevar animDirection:Number = 1;// array of items ***************************************** list the linkage id names here ****************************var arrItems:Array = ["mc0", "mc1", "mc3"];var numOfItems:Number = arrItems.length;// distance or angle between each item along the circumferencevar sectorDistance:Number = ((Math.PI * 2) / numOfItems);//create container items: attach from Library via linkageIDfunction buildCarousel():Void{	for(var i:Number = 0; i < numOfItems; i++)	{		var mc = container.attachMovie(arrItems[i],"item" + i, container.getNextHighestDepth());		mc.angle = i * sectorDistance;		mc.id = i;	}}buildCarousel();// ************* call this function and pass it the index number of the item you wish tto move into the "spotlight" positionfunction itemSelected(idNum:Number):Void{	/* 	loop through each item and "reset" its angle this is to ensure easier tracking and handling of values	ie. if it's previous resting angle was >= 2 * PI (a complete positive circle) or < 0	(gone back beyond 0 due to anti-clockwise rotation) then recalulate an equivalent angle before proceeding	*/	for(var i:Number = 0; i < numOfItems; i++)	{		var mc:MovieClip = container["item"+i];		if(mc.angle >= (Math.PI * 2))		{			mc.angle = mc.angle - Math.PI * 2;		}		if(mc.angle < 0)		{			mc.angle = Math.PI * 2 + mc.angle;		}	}		// if this items current angle is between PI/2 and 1.5PI (ie is currently on the LEFT hand side of circle)	// then set to travel anti-clockwise (shortest path) and calculate how far it needs to travel to be at PI/2 (middle front)	if(container["item"+idNum].angle <= 1.5 * Math.PI && container["item"+idNum].angle > Math.PI / 2)	{		animDirection = -1;		distToTravel = container["item"+idNum].angle - Math.PI / 2;	}	else	{		// else travelling clockwise 		animDirection = 1;		if(container["item"+idNum].angle >= 0 && container["item"+idNum].angle <= Math.PI / 2)		{			distToTravel = Math.PI / 2 - container["item"+idNum].angle;		}		else		{			distToTravel = Math.PI / 2 + (2 * Math.PI - container["item"+idNum].angle);		}	}	//loop through all items	for(var i:Number = 0; i < numOfItems; i++)	{		var mc:MovieClip = container["item"+i];				if(i == idNum)		{			//the selected items destination is set to PI (middle front of screen)			mc.dest = Math.PI / 2;						// item in focus - alpha 100%			mc._alpha = 100;		}		else		{			//calculate this items destination			mc.dest = mc.angle + (animDirection * distToTravel);						// not the item in focus - alpha back a bit			mc._alpha = alphaAmount;		}		if(animDirection == 1 && mc.angle > mc.dest)		{			mc.dest = mc.dest + Math.PI * 2;		}		mc.onEnterFrame = animate;	}}function animate(){	// track whether destination has been reached	var kill:Boolean = false;		// set the blur and attach	blur.blurX = 40;	container.filters = [blur];		// temp calculate where the next onEnterframe would position this item	var newAngle:Number = this.angle + animDirection * speed;					// travelling clockwise	if(animDirection == 1)	{		if(newAngle >= this.dest)		{			//we've gone PAST our intended destination so set angle TO destination			this.angle = this.dest;			kill = true;		}		else		{			//set new angle			this.angle = newAngle;		}	// travelling anti-clockwise	}	else	{		if(newAngle <= this.dest)		{			//we've gone PAST our intended destination so set angle TO destination			this.angle = this.dest;			kill = true;		}		else		{			//set new angle			this.angle = newAngle;		}	}	// set x, y position and scale	this._x = Math.cos(this.angle) * radiusX + centerX;	this._y = Math.sin(this.angle) * radiusY + centerY;	var s = (this._y - perspective) / (centerY + radiusY - perspective);	this._xscale = this._yscale = s * 100;	this.swapDepths(Math.round(this._xscale) + 100);	if(kill)	{		// remove the blur		container.filters = [];		// stop this item from animating		delete this.onEnterFrame;	}}// START THIS BABY UP!!!// itemSelected(0);