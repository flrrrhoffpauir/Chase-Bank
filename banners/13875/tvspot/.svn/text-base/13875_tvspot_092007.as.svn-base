// 13875_tvspot_092007.as/*The video has been encoded using the following encoding profile:  ChaseTVspot_flv_encoder_profile.xml*/// vars   ----------------------------------------------------------------------------------------- // visual assetsvar mcVidController:MovieClip;var mcPlay:MovieClip;var mcBuffer:MovieClip;// interval id'svar vidLoaderID:Number;var nsLoaderID:Number;var soundID:Number;var scrubID:Number;var vidDuration:Number; // total seconds of video// used to reset at completion of video playbackvar loaderBarReset:Number = mcVidController.mcLoader.mcLoaderBar._width;// path to external flvvar videoPath:String = "tv/spinchange_400x230.flv";// objects   --------------------------------------------------------------------------------------// set up the connvar nc:NetConnection = new NetConnection();nc.connect(null); // not using the FlashCommunicationServervar ns:NetStream = new NetStream(nc);// trap the sound of the video, control volumethis.createEmptyMovieClip("mcVidSound", this.getNextHighestDepth());mcVidSound.attachAudio(ns);var vidSound:Sound = new Sound(mcVidSound);// find the total time of the video in secondsns["onMetaData"] = function(obj:Object):Void{	vidDuration = obj.duration;}// functions   ------------------------------------------------------------------------------------// used to show the user the video bufferfunction vidLoaderStatus():Void{	var loaderWidth:Number = mcVidController.mcLoader._width;	var amtLoaded:Number = ns.bytesLoaded / ns.bytesTotal;	mcVidController.mcLoader.mcLoaderBar._width = amtLoaded * loaderWidth;	mcVidController.mcLoader.mcScrubber._x = ns.time / vidDuration * loaderWidth;	if(mcVidController.mcLoader.mcLoaderBar._width > loaderBarReset) { mcVidController.mcLoader.mcLoaderBar._width = loaderBarReset; };	if(mcVidController.mcLoader.mcScrubber._x > mcVidController.mcLoader.mcLoaderBar._width) { mcVidController.mcLoader.mcScrubber._x = 0; };}// used to seek() within the video function scrubVideo():Void{	ns.seek(Math.floor((mcVidController.mcLoader.mcScrubber._x / mcVidController.mcLoader._width) * vidDuration));}// used to adjust the volume and display the time elapsedfunction adjustVolumeAndTime():Void{	var vol:Number = (mcVidController.mcSoundControl.mcSoundTab._x / mcVidController.mcSoundControl.mcSoundTrack._width) * 100;	vidSound.setVolume(vol);		var mins:String;	var secs:String;	var minutes:Number = Math.floor(ns.time / 60);    var seconds:Number = Math.floor(ns.time % 60);	mins = String(minutes);	secs = String(seconds);    if(minutes < 10) { mins = "0" + minutes; };	if(seconds < 10) { secs = "0" + seconds; };    mcVidController.txtTime.text = "0:" + mins + ":" + secs;}// used to display the amount of data buffered function checkNSBytesLoaded():Void{	var percent:Number = Math.round((ns.bytesLoaded / ns.bytesTotal) * 100);	mcBuffer.txtPercent.text = String(percent) + " %";    if(percent >= 100) { clearInterval(nsLoaderID); };}// handlers   -------------------------------------------------------------------------------------// buffer/playbackns.onStatus = function(info:Object):Void{	switch(info.code)	{		case "NetStream.Buffer.Empty":			// show the buffer			mcBuffer._visible = true;			break;		case "NetStream.Buffer.Full":			// hide the buffer			mcBuffer._visible = false;			break;		case "NetStream.Play.Stop":			// return to beginning of video			ns.seek(0);			ns.pause();						// reset the controls			mcVidController.mcLoader.mcLoaderBar._width = loaderBarReset;			mcVidController.mcLoader.mcScrubber._x = 0;			mcVidController.mcPlayPause.gotoAndStop("play");			break;	}}mcVidController.mcPlayPause.onRelease = function():Void{	ns.pause(); // acts as a toggle switch - play/pause	var pos:String = (mcVidController.mcPlayPause._currentframe == 1) ? "pause" : "play";	this.gotoAndStop(pos); // toggle the appearance}mcVidController.mcLoader.mcScrubber.onPress = function():Void{	// stop the vidLoaderStatus() and start the scrubVideo()	clearInterval(vidLoaderID);	scrubID = setInterval(this._parent._parent._parent, "scrubVideo", 10);	this.startDrag(false, 0, this._y, mcVidController.mcLoader._width, this._y);}mcVidController.mcLoader.mcScrubber.onRelease = mcVidController.mcLoader.mcScrubber.onReleaseOutside = function():Void{	// stop the scrubVideo() and start the vidLoaderStatus()	clearInterval(scrubID);	vidLoaderID = setInterval(this._parent._parent._parent, "vidLoaderStatus", 100);	this.stopDrag();}mcVidController.mcSoundControl.mcSoundTab.onPress = function():Void{	this.startDrag(false, 0, this._y, this._parent.mcSoundTrack._width, this._y);}mcVidController.mcSoundControl.mcSoundTab.onRelease = function():Void{	this.stopDrag();}// run   ------------------------------------------------------------------------------------------// reset the value displayedmcBuffer.txtPercent.text = "0 %";vidObj.attachVideo(ns);  // connect the stream to the video objectns.setBufferTime(30); // amount of video in seconds to buffer before playing// start all of the functionsclearInterval(nsLoaderID);nsLoaderID = setInterval(this, "checkNSBytesLoaded", 10);clearInterval(vidLoaderID);vidLoaderID = setInterval(this, "vidLoaderStatus", 100);clearInterval(soundID);soundID = setInterval(this, "adjustVolumeAndTime", 10);// show the buffer panel mcBuffer._visible = true;// autoplayns.play(videoPath);mcVidController.mcPlayPause.gotoAndStop("pause");